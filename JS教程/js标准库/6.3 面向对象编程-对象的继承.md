6.3 面向对象编程-继承
===========================

*《JavaScript教程》作者：阮一峰*

JavaScript 的继承是通过构造函数（constructor）和 “原型对象”（prototype）实现的。

**构造函数的缺点**

同一个构造函数的多个实例之间，无法共享属性。

**解决办法**

使用原型对象。

**原型对象**

JavaScript 继承机制的设计思想就是，原型对象（prototype）的所有属性和方法，都能被实例对象共享。

JavaScript 规定，每个函数都有一个 prototype 属性，指向一个原型对象。对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。

**原型链**

JavaScript 规定，所有对象都有自己的原型对象（prototype）。原型对象也是对象，所以它也有自己的原型，由此，形成了一条原型链（prototype chain）。

任何一个对象，都可以充当其他对象的原型。

如果一层层地上溯，所有对象的原型最终都可以上溯到 Object.prototype，即 Object 构造函数的 prototype 属性。也就是说，所有对象都继承了 Object.prototype 的属性。这就是所有对象都有 valueOf 和 toString 方法的原因，因为这是从 Object.prototype 继承的。

那么，Object.prototype 对象有没有它的原型呢？回答是 Object.prototype 的原型是 null。null 没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是 null。

**读取对象属性的过程**

读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的 Object.prototype 还是找不到，则返回 undefined。

如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。

注意，在整个原型链上寻找某个属性，对性能是有影响的。如果寻找某个不存在的属性，将会遍历整个原型链。

**原型对象的 constructor 属性**

prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。

constructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。

修改原型对象时，一般要同时修改constructor属性的指向。

**instanceof运算符**

instanceof运算符用来判断一个对象是否为某个构造函数的实例。

instanceof的原理是检查右边构造函数的prototype属性，是否在左边对象的原型链上。有一种特殊情况，就是左边对象的原型链上，只有null对象。这时，instanceof判断会失真。

instanceof运算符的一个用处，是判断值的类型。

注意，instanceof运算符只能用于对象，不适用原始类型的值。

此外，对于undefined和null，instanceof运算符总是返回false。

利用instanceof运算符，还可以巧妙地解决，调用构造函数时，忘了加new命令的问题。

**构造函数的继承**

让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现：

第一步是在子类的构造函数中，调用父类的构造函数。
第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。（使用 Object.create() 创建一个父类原型的副本，然后再赋值给子类原型，以避免直接修改父类的原型。）

**多重继承**

JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。子类同时继承两个父类的这种模式又称为 Mixin（混入）。

**模块**

模块是实现特定功能的一组属性和方法的封装。

**基本的实现方法**

简单的做法是把模块写成一个对象，所有的模块成员都放到这个对象里面。使用的时候，就是调用这个对象的属性。但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。

**利用构造函数，封装私有变量**

这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。

**使用“立即执行函数”，封装私有变量**

使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。

如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。

**模块的放大模式**：改进立即执行函数，使其可以传入参数--其他模块。
**宽放大模式**：就是“立即执行函数”的参数可以是空对象。
**输入全局变量**：独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。为了在模块内部调用全局变量，必须显式地将其他变量输入模块。

